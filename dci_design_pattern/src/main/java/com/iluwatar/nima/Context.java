package com.iluwatar.nima;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.HashMap;public class Context {	private int Amount;	HashMap<String, Object> transMap;	// conduct transfer operation	public void transfer (int money, int from_account , int des_account , Bank bank) {		// map each role		Amount = money;		// create a new hashmap to store account information and amount value, otherwise,		// nullpointerexception will occur.		transMap = new HashMap<>();		transMap.put("SOURCE", bank.getAccount(from_account));		transMap.put("DESTINATION", bank.getAccount(des_account));		// conduct operation		request ("SOURCE", "sendTo",new Object[]{});	}	public void receive (int amount,int from_account , int des_account , Bank bank ){		Amount = amount;		transMap = new HashMap<>();		transMap.put("SOURCE", bank.getAccount(from_account));		transMap.put("DESTINATION", bank.getAccount(des_account));		request("DESTINATION","sendFrom", new Object[]{});	}	//THE ROLE CLASS WITH ROLE METHODS	class SOURCEACCOUNT {		public Object sendTo() {			if ((Integer) request ("SOURCE" , "balance", new Object[]{}) < Amount) {				System.out.println("Sorry, the funds is insufficient, transaction cancelled. ");			} else {				request ("SOURCE" , "decrease" , new Object[] {Amount} );				//call ("DESTINATION", "sendFrom", new Object[]{Amount});			} ;			return null;		}	}	class DESTINATIONACCOUNT {		public Object sendFrom() {			request ("DESTINATION" , "increase" , new Object[] {Amount});			return null;		}	}	//The execution engine	private Object request(String roleName, String method , Object[] objs)	{		// read the inner role class name, eg: SOURCEACCOUNT		String roleNameClass = "Context$" + roleName + "ACCOUNT";		Class<Object> roleClassName;		// initialize an instance		Object instance;		Method roleMethodName = null;		// initialize data class		Method dMethod = null;		try {			// attempt to execute role methods.			roleClassName = (Class<Object>) Class.forName (roleNameClass );			// get the role class method			Method[] roleMethods = roleClassName.getDeclaredMethods();			for(Method m : roleMethods){				if (m.getName() .equals(method)){					roleMethodName =m;				}			};			// if the method exist, then set it accessible			if (roleMethodName != null) {				roleMethodName.setAccessible(true);				roleClassName.getDeclaredConstructor(Context.class).setAccessible(true);				instance = roleClassName.getDeclaredConstructor(Context.class).newInstance(this);				// execute the method				return roleMethodName.invoke (instance );			}			// try to execute instance method when there is no role method			Method [] dMethods = transMap.get(roleName).getClass().getDeclaredMethods();			for (Method m1 : dMethods){				if (m1.getName() .equals(method)){					dMethod = m1;				}			}			if (dMethod == null) {				return null;			}			else{				return dMethod.invoke (transMap.get(roleName), objs);			}		} catch ( NoSuchMethodException | IllegalAccessException | ClassNotFoundException | InstantiationException | InvocationTargetException | IllegalArgumentException ex4) {ex4.printStackTrace();		}		return null;	}}