package com.iluwatar.nima;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.HashMap;public class Context {	private Integer Amount;	HashMap<String, Object> transMap;	// conduct transfer operation		public void transfer (Integer money, Integer from_account , Integer des_account , Bank bank) {		// map each role		Amount = money;		Account SourceACCOUNT = bank.getAccount(from_account);		Account DestinationACCOUNT = bank.getAccount(des_account);		transMap = new HashMap<>();		transMap.put("SOURCE", SourceACCOUNT);		transMap.put("DESTINATION", DestinationACCOUNT);		transMap.put("AMOUNT", Amount);		// conduct operation		call ("SOURCE", "sendTo");	}	//THE ROLE CLASS WITH ROLE METHODS		class SOURCEACCOUNT {		public Object sendTo() {			if ((Integer) call ("SOURCE" , "balance") < Amount) {				System.out.println("Sorry, the funds is insufficient, transaction cancelled. ");			} else {				Object[] args = {Amount};				call ("SOURCE" , "decrease" , args ); 				call ("DESTINATION", "sendFrom");			} ;			return(null);		}	}	class DESTINATIONACCOUNT {		public Object sendrFrom() {			Object[] args = {Amount};			call ("DESTINATION" , "increase" , args ); 			return(null);		}	}	//          The execution engine		private Object call(String roleName, String method) {		Object[] objs = {};		return (call (roleName, method , objs));	}		private Object call(String roleName, String method , Object[] objs)	{		String roleNameClass = "Context$" + roleName + "ACCOUNT";		Class<Object> roleClassName = null ;		Object instance = null;		Method roleMethodName = null;		Object dObject = null;		Class dClass = null;		Method dMethod = null;		try {			// attempt to execute role methods.			roleClassName = (Class<Object>) Class.forName (roleNameClass );			Method[] roleMethods = roleClassName.getDeclaredMethods();			for(Method m : roleMethods){				if (m.getName() .equals(method)){					roleMethodName =m;				}			};					if (roleMethodName != null) {				roleMethodName.setAccessible(true);				Constructor<Object> roleConstructor = roleClassName.getDeclaredConstructor(Context.class);				roleConstructor.setAccessible (true);				instance  = roleConstructor.newInstance (this);				return roleMethodName.invoke (instance );			} 			// try to execute instance method when there is no role method			dObject = transMap.get(roleName);			dClass = dObject.getClass();			Method[] dMethods = dClass.getDeclaredMethods();			for (Method m1 : dMethods){				if (m1.getName() .equals(method)){					dMethod = m1;				}			}			if (dMethod == null) {				System.out.println("request " + method + "does not found");				return (null);				}			return dMethod.invoke (dObject, objs);		} catch ( NoSuchMethodException | IllegalAccessException | ClassNotFoundException | InstantiationException | InvocationTargetException | IllegalArgumentException ex4) {ex4.printStackTrace();		}		return(null);}	}